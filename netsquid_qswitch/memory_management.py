"""Tools for tracking the entanglement that a node holds with remote nodes."""
from collections import namedtuple
import numpy as np
import netsquid as ns


class LinkIDCreator:
    """
    Class for drawing fresh link IDs.

    Intended usage:

      * each node holds a single `LinkIDCreator` object
      * the `LinkIDCreator` object is instantiated by giving it a list
        of remote node names
      * for each time the node generates bipartitate entanglement (link)
        with remote node X, an ID for the link can be generated by
        calling `LinkIDCreator.get_fresh_link_ID(X)`. When called multiple
        times on the same remote node name, this method will never return
        the same link ID twice.

    Inner working: keeps a "link ID counter" for each remote node,
    which is incremented each time `LinkIDCreate.get_fresh_link_ID` is called.
    """

    def __init__(self):
        """
        Parameters
        ----------
        remote_node_names : list of str
        """
        self.reset()

    def reset(self):
        """
        Reset all internal link ID counters.
        """
        self._node_names2link_ID_counter = {}

    def get_fresh_link_ID(self, remote_node_name):
        """
        remote_node_name : str
        """
        if remote_node_name not in self._node_names2link_ID_counter:
            self._node_names2link_ID_counter[remote_node_name] = -1
        self._node_names2link_ID_counter[remote_node_name] += 1
        return self._node_names2link_ID_counter[remote_node_name]


Link = namedtuple("Link", ("remote_node_name",
                           "link_ID",
                           "generation_time_stamp",
                           "timeout"))


class LinkGroup:

    def __init__(self, links):
        self.links = links
        self.correction_operators = [None for __ in links]

    @property
    def group_ID(self):
        return hash(self.links)

    def __str__(self):
        return str([str(link) for link in self.links])

    def __repr__(self):
        return str(self)


class MemoryManager:
    """
    Database for tracking the bipartite entanglement (link) that a node holds
    with a remote node.

    Intended usage: to be kept in parallel to a QuantumProcessor. Each time
    a new link is created, locally swapped ('moved') or removed from the
    QuantumProcessor, the `MemoryManager` should be manually updated
    using the corresponding methods (`add_fresh_link`, `move_link`,
    `remove_link`).

    Parameters
    ----------
    num_positions : int
        Number of memory positions in the database.
        If the MemoryManager is used in parallel to a QuantumProcessor,
        `num_positions` equals the number of memory positions in the
        QuantumProcessor.
    decoherence_rate : float
    """

    def __init__(self, node_name, num_positions, decoherence_rate=0):
        self._node_name = node_name
        self._num_positions = num_positions
        if decoherence_rate < 0:
            raise ValueError("Decoherence rate cannot be negative")
        self._decoherence_rate = decoherence_rate
        self._rng = ns.util.simtools.get_random_state()
        self.reset()

    def reset(self):
        """
        Empty the database.
        """
        self._mem_pos2info = {}

    @property
    def remote_node_names(self):
        """
        set of str

        All names of remote nodes of which the `MemoryManager` holds
        links to.
        """
        ret = set()
        for __, info in self._mem_pos2info.items():
            ret.add(info.remote_node_name)

        return ret

    def add_fresh_link(self, mem_pos, remote_node_name, fresh_link_ID):
        """
        Add a link to the database.

        Parameters
        ----------
        mem_pos : int
            Position in memory at which local qubit of the link
            resides.
        remote_node_name : str
        fresh_link_ID : int
            ID of the link.

        Returns
        -------
        :obj:`quantum_switch.memory_management.Link`

        Raises
        ------
        ValueError if `mem_pos` already exists in the database or
        when `fresh_link_ID` is already in use for node `remote_node_name`.
        """
        # check if memory position is already taken
        if mem_pos in self._mem_pos2info:
            raise ValueError(
                "Memory position {} already in use".format(mem_pos))

        # check if the link_ID is already taken
        all_entment = self.get_all_links_with(remote_node_name)
        for info in all_entment.values():
            if info.link_ID == fresh_link_ID:
                raise ValueError(
                    "Link ID {} with remote node {} already exists"
                    .format(fresh_link_ID, remote_node_name))

        # determine the link's timeout
        if self._decoherence_rate == 0:
            timeout = np.inf
        else:
            timeout = ns.sim_time() + \
                self._rng.exponential(scale=1. / self._decoherence_rate)

        # add the new link to the database
        link = Link(remote_node_name=remote_node_name,
                    link_ID=fresh_link_ID,
                    generation_time_stamp=ns.sim_time(),
                    timeout=timeout)
        self._mem_pos2info[mem_pos] = link

        return link

    def apply_timeout(self):
        """
        Remove all links that have timed out, i.e. for which the current
        time is more than their timeout time.

        Returns
        -------
        list of tuple (str, int)
            List of (remote node name, link ID) of each of the links
            that "timed out".
        """
        ret = []
        mem_positions = list(self._mem_pos2info.keys())
        for mem_pos in mem_positions:
            info = self._mem_pos2info[mem_pos]
            if info.timeout < ns.sim_time():
                ret.append(info)
                self.remove_link(mem_pos)
        return ret

    def remove_link(self, mem_pos):
        """
        Remove a link from the database.

        Parameters
        ----------
        mem_pos : int

        Returns
        -------
        Tuple (str, int)
            Remote node name and link ID of the removed link.
        """
        info = self._mem_pos2info[mem_pos]
        ret = (info.remote_node_name, info.link_ID)
        del self._mem_pos2info[mem_pos]
        return ret

    def get_position(self, remote_node_name, link_ID):
        """
        Memory position at which a link resides.

        Parameters
        ----------
        remote_node_name : str
        link_ID : int

        Returns
        -------
        int
        """
        for pos, link in self._mem_pos2info.items():
            if link.remote_node_name == remote_node_name \
                    and link.link_ID == link_ID:
                return pos
        raise Exception("Position not present")

    def move_link(self, old_mem_pos, new_mem_pos):
        """
        Perform local swap, i.e. 'move' a qubit from one memory position
        to another.

        Parameters
        ----------
        old_mem_pos : int
        new_mem_pos : int
        """
        info = self._mem_pos2info[old_mem_pos]
        self.remove_link(old_mem_pos)
        self._mem_pos2info[new_mem_pos] = info

    def get_link(self, mem_pos):
        """
        Query the information that the MemoryManager has for the link
        on a given memory position.

        Parameters
        ----------
        mem_pos : int

        Returns
        -------
        Link object

        Raises
        ------
        ValueError if the MemoryManager has no link on memory
        position `mem_pos`.
        """
        if mem_pos not in self._mem_pos2info:
            raise ValueError("Memory position {} not in use in MemoryManager"
                             .format(mem_pos))
        link = self._mem_pos2info[mem_pos]
        return link

    def get_all_links_with(self, remote_node_name):
        """
        Query all links with a given remote node, that the MemoryManager holds.

        Returns
        -------
        dictionary int : MemoryManager._Info
            Key=memory position and value=link information.

        Internal working
        ----------------
        The return value is a sub-dictionary of `self._mem_pos2info`.
        """
        ret = {}
        for pos, info in self._mem_pos2info.items():
            if info.remote_node_name == remote_node_name:
                ret[pos] = info
        return ret

    @staticmethod
    def _sort_by_OLEF(tuple_of_mem_pos_and_info):
        """sort by OLEF-rule (Oldest Link Entanglement First)"""
        return tuple_of_mem_pos_and_info[1].generation_time_stamp

    def get_connectable_positions(self, number_of_qubits, server_node_name=None):
        """
        Check whether a `Connect` operation is possible, where the
        number of qubits that the `Connect` operation acts upon is
        given by `number_of_qubits`. Specifying a server_node returns the group of oldest links
        where server_node_name is part of.

        Parameters
        ----------
        number_of_qubits : int

        Returns
        ----------
        list of int or None

        Notes
        -----
        Based on the Oldest Link Entanglement First (OLEF) rule.
        """

        def get_oldest_entanglement_with(memorymanager, remote_node_name):
            all_links = memorymanager.get_all_links_with(remote_node_name)
            if len(all_links) == 0:
                return None
            all_links = list(all_links.items())
            all_links.sort(key=MemoryManager._sort_by_OLEF)
            return all_links[0]

        oldest_links = []
        for remote_node_name in self.remote_node_names:
            oldest = get_oldest_entanglement_with(self, remote_node_name)
            if oldest is not None:
                oldest_links.append(oldest)
        oldest_links.sort(key=MemoryManager._sort_by_OLEF)
        if len(oldest_links) < number_of_qubits:
            return None
        if server_node_name is None:
            return [x[0] for x in oldest_links[0:number_of_qubits]]
        
        node_names = [oldest_link[1].remote_node_name for oldest_link in oldest_links]
        if server_node_name in node_names:
            index_server = node_names.index(server_node_name)
            server_link = oldest_links[index_server]
            positions = [server_link[0]] + [x[0] for i, x in enumerate(oldest_links)
                                            if i != index_server][:number_of_qubits-1]
            return positions
        return None

    def positions_to_discard_following_buffer_by_remote_node_name(self, remote_node_name, buffer_size):
        """Checks whether more than `buffer_size` links are present,
        entanglement to `remote_node_name`. Identifies the oldest of those
        until their number no longer is strictly larger than the buffer size,
        and returns their memory positions.

        Parameters
        ----------
        remote_node_name: str
        buffer_size: int

        Returns
        -------
        list of int
            List of memory positions.
        """

        if buffer_size < 0:
            raise ValueError("Buffer size should be nonnegative")
        if buffer_size == np.inf:
            # if the buffer size is unbounded, then no links need to
            # be discarded
            return []

        all_links = self.get_all_links_with(remote_node_name)
        if len(all_links) > buffer_size:
            links = list(all_links.items())
            links.sort(key=MemoryManager._sort_by_OLEF)
            number_of_links_to_discard = len(links) - buffer_size
            links_to_discard = links[:number_of_links_to_discard]
            return [pos for pos, __ in links_to_discard]
        else:
            return []

    @property
    def positions_in_use(self):
        """list of int"""
        return list(self._mem_pos2info.keys())

    def get_free_mem_positions(self, possible_mem_pos="default", number_of_positions=1):
        """
        Returns a free memory position among `possible_mem_pos`.
        If `possible_mem_pos` is not specified, then it is assumed
        that all memory positions are possible.

        Parameters
        ----------
        possible_mem_pos : list of int

        Returns
        ----------
        int

        Notes
        -----
        Returns the free memory position with the smallest position index.
        I.e. if positions 3, 9 and 5 are free, then 3 is returned.
        """
        if possible_mem_pos == "default":
            possible_mem_pos = list(range(self._num_positions))
        free_positions = [mem_pos for mem_pos in possible_mem_pos
                          if mem_pos not in self._mem_pos2info]
        if len(free_positions) < number_of_positions:
            raise Exception(f"No more free memory positions available at node {self._node_name}.")
        else:
            return free_positions[:number_of_positions]
